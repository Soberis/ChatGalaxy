# Pull Request Automation & Branch Protection
# 2025å¹´æ ‡å‡†çš„PRè‡ªåŠ¨åŒ–æ£€æŸ¥å’Œåˆ†æ”¯ä¿æŠ¤å·¥ä½œæµ

name: PR Checks & Branch Protection

on:
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]
  issue_comment:
    types: [created]

env:
  NODE_VERSION: '20.19.0'
  PYTHON_VERSION: '3.11'
  PNPM_VERSION: '9'

jobs:
  # PRä¿¡æ¯éªŒè¯
  pr-validation:
    name: PR Validation
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: éªŒè¯PRæ ‡é¢˜æ ¼å¼
      uses: amannn/action-semantic-pull-request@v5
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        types: |
          feat
          fix
          docs
          style
          refactor
          perf
          test
          build
          ci
          chore
          revert
        scopes: |
          frontend
          backend
          api
          ui
          auth
          chat
          deploy
          security
          deps
        requireScope: false
        disallowScopes: |
          release
        subjectPattern: ^(?![A-Z]).+$
        subjectPatternError: |
          The subject "{subject}" found in the pull request title "{title}"
          didn't match the configured pattern. Please ensure that the subject
          doesn't start with an uppercase character.
          
    - name: æ£€æŸ¥PRæè¿°
      uses: actions/github-script@v7
      with:
        script: |
          const { data: pullRequest } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });
          
          const body = pullRequest.body || '';
          const minLength = 50;
          
          if (body.length < minLength) {
            core.setFailed(`PR description is too short (${body.length} chars). Please provide at least ${minLength} characters describing your changes.`);
          }
          
          // æ£€æŸ¥æ˜¯å¦åŒ…å«å¿…è¦çš„ä¿¡æ¯
          const requiredSections = ['## Changes', '## Testing'];
          const missingSections = requiredSections.filter(section => !body.includes(section));
          
          if (missingSections.length > 0) {
            core.warning(`PR description is missing recommended sections: ${missingSections.join(', ')}`);
          }
          
    - name: æ£€æŸ¥æ–‡ä»¶å˜æ›´èŒƒå›´
      uses: actions/github-script@v7
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });
          
          const maxFiles = 50;
          const maxAdditions = 1000;
          
          if (files.length > maxFiles) {
            core.warning(`This PR modifies ${files.length} files, which is quite large. Consider breaking it into smaller PRs.`);
          }
          
          const totalAdditions = files.reduce((sum, file) => sum + file.additions, 0);
          if (totalAdditions > maxAdditions) {
            core.warning(`This PR adds ${totalAdditions} lines, which is quite large. Consider breaking it into smaller PRs.`);
          }
          
          // æ£€æŸ¥æ˜¯å¦åŒæ—¶ä¿®æ”¹å‰ç«¯å’Œåç«¯
          const frontendFiles = files.filter(f => f.filename.startsWith('frontend/'));
          const backendFiles = files.filter(f => f.filename.startsWith('backend/'));
          
          if (frontendFiles.length > 0 && backendFiles.length > 0) {
            core.warning('This PR modifies both frontend and backend code. Consider splitting into separate PRs for easier review.');
          }
          
  # å¿«é€Ÿæ£€æŸ¥
  quick-checks:
    name: Quick Checks
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: æ£€æŸ¥æ•æ„Ÿæ–‡ä»¶å˜æ›´
      run: |
        # æ£€æŸ¥æ˜¯å¦ä¿®æ”¹äº†æ•æ„Ÿé…ç½®æ–‡ä»¶
        SENSITIVE_FILES="
        package.json
        requirements.txt
        Dockerfile
        docker-compose.yml
        vercel.json
        render.yaml
        .github/workflows/
        "
        
        CHANGED_SENSITIVE_FILES=""
        for file in $SENSITIVE_FILES; do
          if git diff --name-only origin/main...HEAD | grep -q "^$file"; then
            CHANGED_SENSITIVE_FILES="$CHANGED_SENSITIVE_FILES\n- $file"
          fi
        done
        
        if [ -n "$CHANGED_SENSITIVE_FILES" ]; then
          echo "âš ï¸ Sensitive files modified:$CHANGED_SENSITIVE_FILES" >> $GITHUB_STEP_SUMMARY
          echo "Please ensure these changes are reviewed carefully." >> $GITHUB_STEP_SUMMARY
        fi
        
    - name: æ£€æŸ¥TODOå’ŒFIXME
      run: |
        # æŸ¥æ‰¾æ–°å¢çš„TODOå’ŒFIXME
        TODO_COUNT=$(git diff origin/main...HEAD | grep -c "^+.*\(TODO\|FIXME\|XXX\|HACK\)" || true)
        
        if [ $TODO_COUNT -gt 0 ]; then
          echo "âš ï¸ Found $TODO_COUNT new TODO/FIXME comments" >> $GITHUB_STEP_SUMMARY
          echo "Consider addressing these before merging:" >> $GITHUB_STEP_SUMMARY
          git diff origin/main...HEAD | grep "^+.*\(TODO\|FIXME\|XXX\|HACK\)" | head -10 >> $GITHUB_STEP_SUMMARY || true
        fi
        
    - name: æ£€æŸ¥è°ƒè¯•ä»£ç 
      run: |
        # æŸ¥æ‰¾å¯èƒ½çš„è°ƒè¯•ä»£ç 
        DEBUG_PATTERNS="console\.log\|debugger\|print(\|pdb\.set_trace\|breakpoint()"
        DEBUG_COUNT=$(git diff origin/main...HEAD | grep -c "^+.*\($DEBUG_PATTERNS\)" || true)
        
        if [ $DEBUG_COUNT -gt 0 ]; then
          echo "âš ï¸ Found $DEBUG_COUNT potential debug statements" >> $GITHUB_STEP_SUMMARY
          echo "Please remove debug code before merging:" >> $GITHUB_STEP_SUMMARY
          git diff origin/main...HEAD | grep "^+.*\($DEBUG_PATTERNS\)" | head -5 >> $GITHUB_STEP_SUMMARY || true
        fi
        
  # è‡ªåŠ¨åŒ–PRæ ‡ç­¾
  auto-labeling:
    name: Auto Labeling
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      
    - name: è‡ªåŠ¨æ·»åŠ æ ‡ç­¾
      uses: actions/github-script@v7
      with:
        script: |
          const { data: files } = await github.rest.pulls.listFiles({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });
          
          const labels = [];
          
          // æ ¹æ®æ–‡ä»¶å˜æ›´æ·»åŠ æ ‡ç­¾
          const frontendFiles = files.filter(f => f.filename.startsWith('frontend/'));
          const backendFiles = files.filter(f => f.filename.startsWith('backend/'));
          const docsFiles = files.filter(f => f.filename.match(/\.(md|txt|rst)$/i));
          const testFiles = files.filter(f => f.filename.includes('test') || f.filename.includes('spec'));
          const configFiles = files.filter(f => f.filename.match(/\.(json|yml|yaml|toml|ini|conf)$/));
          
          if (frontendFiles.length > 0) labels.push('frontend');
          if (backendFiles.length > 0) labels.push('backend');
          if (docsFiles.length > 0) labels.push('documentation');
          if (testFiles.length > 0) labels.push('tests');
          if (configFiles.length > 0) labels.push('configuration');
          
          // æ ¹æ®å˜æ›´å¤§å°æ·»åŠ æ ‡ç­¾
          const totalChanges = files.reduce((sum, file) => sum + file.additions + file.deletions, 0);
          if (totalChanges < 50) {
            labels.push('size/small');
          } else if (totalChanges < 200) {
            labels.push('size/medium');
          } else {
            labels.push('size/large');
          }
          
          // æ ¹æ®PRæ ‡é¢˜æ·»åŠ æ ‡ç­¾
          const title = context.payload.pull_request.title.toLowerCase();
          if (title.includes('feat')) labels.push('enhancement');
          if (title.includes('fix')) labels.push('bug');
          if (title.includes('security')) labels.push('security');
          if (title.includes('perf')) labels.push('performance');
          if (title.includes('refactor')) labels.push('refactoring');
          
          // æ·»åŠ æ ‡ç­¾
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: labels
            });
          }
          
  # PRè¯„è®ºå‘½ä»¤å¤„ç†
  pr-commands:
    name: PR Commands
    runs-on: ubuntu-latest
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request
    
    steps:
    - name: å¤„ç†PRå‘½ä»¤
      uses: actions/github-script@v7
      with:
        script: |
          const comment = context.payload.comment.body.trim();
          const commenter = context.payload.comment.user.login;
          
          // æ£€æŸ¥æƒé™
          const { data: collaborator } = await github.rest.repos.getCollaboratorPermissionLevel({
            owner: context.repo.owner,
            repo: context.repo.repo,
            username: commenter
          });
          
          const hasPermission = ['admin', 'write'].includes(collaborator.permission);
          
          if (!hasPermission) {
            console.log(`User ${commenter} does not have permission to run commands`);
            return;
          }
          
          // å¤„ç†ä¸åŒå‘½ä»¤
          if (comment === '/rerun-ci') {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'ğŸ”„ Rerunning CI checks...'
            });
            
            // è§¦å‘é‡æ–°è¿è¡Œå·¥ä½œæµ
            const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              head_sha: context.payload.issue.pull_request.head.sha
            });
            
            for (const run of runs.workflow_runs.slice(0, 3)) {
              if (run.status === 'completed' && run.conclusion === 'failure') {
                await github.rest.actions.reRunWorkflow({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: run.id
                });
              }
            }
          }
          
          if (comment === '/ready-for-review') {
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              draft: false
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: 'âœ… PR marked as ready for review!'
            });
          }
          
          if (comment.startsWith('/assign ')) {
            const assignees = comment.replace('/assign ', '').split(' ').map(u => u.replace('@', ''));
            
            await github.rest.issues.addAssignees({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              assignees: assignees
            });
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `ğŸ‘¥ Assigned to: ${assignees.map(u => '@' + u).join(', ')}`
            });
          }
          
  # åˆ†æ”¯ä¿æŠ¤çŠ¶æ€æ£€æŸ¥
  branch-protection-status:
    name: Branch Protection Status
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    steps:
    - name: æ£€æŸ¥åˆ†æ”¯ä¿æŠ¤çŠ¶æ€
      uses: actions/github-script@v7
      with:
        script: |
          try {
            const { data: protection } = await github.rest.repos.getBranchProtection({
              owner: context.repo.owner,
              repo: context.repo.repo,
              branch: 'main'
            });
            
            let summary = '## ğŸ›¡ï¸ Branch Protection Status\n\n';
            summary += `- **Required Status Checks**: ${protection.required_status_checks ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            summary += `- **Enforce Admins**: ${protection.enforce_admins.enabled ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            summary += `- **Required Reviews**: ${protection.required_pull_request_reviews ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            summary += `- **Dismiss Stale Reviews**: ${protection.required_pull_request_reviews?.dismiss_stale_reviews ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            summary += `- **Require Code Owner Reviews**: ${protection.required_pull_request_reviews?.require_code_owner_reviews ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            summary += `- **Restrict Pushes**: ${protection.restrictions ? 'âœ… Enabled' : 'âŒ Disabled'}\n`;
            
            console.log(summary);
            
          } catch (error) {
            console.log('âš ï¸ Branch protection not configured for main branch');
            console.log('Consider enabling branch protection rules for better security.');
          }
          
  # PRå°±ç»ªæ£€æŸ¥
  pr-ready-check:
    name: PR Ready Check
    runs-on: ubuntu-latest
    needs: [pr-validation, quick-checks]
    if: github.event_name == 'pull_request' && !github.event.pull_request.draft
    
    steps:
    - name: æ£€æŸ¥PRå°±ç»ªçŠ¶æ€
      uses: actions/github-script@v7
      with:
        script: |
          const { data: pullRequest } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });
          
          const { data: reviews } = await github.rest.pulls.listReviews({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number,
          });
          
          const { data: checks } = await github.rest.checks.listForRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: pullRequest.head.sha,
          });
          
          let readyToMerge = true;
          let issues = [];
          
          // æ£€æŸ¥CIçŠ¶æ€
          const failedChecks = checks.check_runs.filter(check => check.conclusion === 'failure');
          if (failedChecks.length > 0) {
            readyToMerge = false;
            issues.push(`âŒ ${failedChecks.length} CI checks failed`);
          }
          
          // æ£€æŸ¥å®¡æ ¸çŠ¶æ€
          const approvedReviews = reviews.filter(review => review.state === 'APPROVED');
          const requestedChanges = reviews.filter(review => review.state === 'CHANGES_REQUESTED');
          
          if (approvedReviews.length === 0) {
            issues.push('â³ No approving reviews yet');
          }
          
          if (requestedChanges.length > 0) {
            readyToMerge = false;
            issues.push('ğŸ”„ Changes requested by reviewers');
          }
          
          // ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
          let statusComment = '## ğŸš¦ PR Status Report\n\n';
          
          if (readyToMerge && approvedReviews.length > 0) {
            statusComment += 'ğŸ‰ **This PR is ready to merge!**\n\n';
            statusComment += 'âœ… All checks passed\n';
            statusComment += `âœ… Approved by: ${approvedReviews.map(r => '@' + r.user.login).join(', ')}\n`;
          } else {
            statusComment += 'â³ **This PR is not ready to merge yet**\n\n';
            statusComment += 'Issues to resolve:\n';
            issues.forEach(issue => {
              statusComment += `- ${issue}\n`;
            });
          }
          
          console.log(statusComment);